from sys.info import sizeof
from runtime.llcl import Runtime
from algorithm import parallelize, num_cores
from math import isnan
from math.limit import isinf

from libc import AF_INET, AF_INET6, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR, SHUT_RDWR
from libc import c_char, c_int, c_uint, c_void
from libc import (
    accept,
    bind,
    c_charptr_to_string,
    htons,
    # inet_ntoa,
    inet_ntop,
    inet_pton,
    listen,
    recv,
    send,
    setsockopt,
    shutdown,
    sockaddr,
    sockaddr_in,
    socket,
    socklen_t,
    strlen,
    to_char_ptr,
)

from config import load_config


# redis tokens
alias REDIS_CRLF = "\r\n"
alias REDIS_STRING = "+"
alias REDIS_ERROR = "-"
alias REDIS_INTEGER = ":"
alias REDIS_BULK_STRING = "$"
alias REDIS_ARRAY = "*"
alias REDIS_NULL = "_"
alias REDIS_BOOL = "#"
alias REDIS_DOUBLE = ","
alias REDIS_BIG_NUMBER = "("
alias REDIS_BULK_ERRORS = "!"
alias REDIS_VERBATIM_STRING = "="
alias REDIS_MAP = "%"
alias REDIS_SET = "~"
alias REDIS_PUSHES = "|"


struct FiredisParser:
    var start: Pointer[UInt8]
    var current: Pointer[UInt8]
    var result: String

    fn __init__(inout self: Self, msg: String):
        let msg_ptr = to_char_ptr(msg)

        self.start = msg_ptr
        self.current = msg_ptr
        self.result = ""

    fn parse(inout self: Self) -> None:
        self.result = "+PONG" + REDIS_CRLF

    fn advance(inout self: Self) -> UInt8:
        self.current = self.current + 1

        return (self.current - 1).load()

    fn peek(inout self: Self) -> UInt8:
        return self.current.load()

    fn peek_next(inout self: Self) -> UInt8:
        return self.current[1]

    fn is_digit(inout self: Self, c: UInt8) -> Bool:
        return c >= ord("0") and c <= ord("9")

    fn is_alpha(inout self: Self, c: UInt8) -> Bool:
        return (c >= ord("a") and c <= ord("z")) or (c >= ord("A") and c <= ord("Z"))

    fn is_at_end(inout self: Self) -> Bool:
        return self.current.load() == 0

    fn match_char(inout self: Self, c: UInt8) -> Bool:
        if self.is_at_end():
            return False

        if self.current.load() != c:
            return False

        self.current += 1
        return True

    fn make_msg(inout self: Self, header: String, msg: String) -> String:
        let msg_len = len(msg)
        let header_len = len(header)
        let buf = Pointer[c_char]().alloc(header_len + msg_len + 2)

        buf.store(0, ord(header))

        for i in range(msg_len):
            buf.store(header_len + i, ord(msg[i]))

        buf.store(header_len + msg_len, ord(String(REDIS_CRLF.data())[0]))
        buf.store(header_len + msg_len + 1, ord(String(REDIS_CRLF.data())[1]))

        return c_charptr_to_string(buf, header_len + msg_len + 2)

    fn make_string(inout self: Self, msg: String) -> String:
        return self.make_msg(REDIS_STRING, msg)

    fn make_error(inout self: Self, msg: String) -> String:
        return self.make_msg(REDIS_ERROR, msg)

    fn make_integer(inout self: Self, msg: Int) -> String:
        return self.make_msg(REDIS_INTEGER, String(msg))

    fn make_bulk_string(inout self: Self, msg: String) -> String:
        let header: String

        if not msg:
            header = REDIS_BULK_STRING + "-1" + REDIS_CRLF
        else:
            header = REDIS_BULK_STRING + String(len(msg)) + REDIS_CRLF

        return self.make_msg(header, msg)

    fn make_array(inout self: Self, msgs: VariadicList[String]) -> String:
        let msgs_len = len(msgs)
        let header = REDIS_ARRAY + String(msgs_len) + REDIS_CRLF
        var result: String = ""

        for msg in range(msgs_len):
            result += msg

        return self.make_msg(header, result)

    fn make_array(inout self: Self, msgs: None) -> String:
        let header = REDIS_ARRAY + "-1"

        return self.make_msg(header, "")

    fn make_null(inout self: Self) -> String:
        return self.make_msg(REDIS_NULL, "")

    fn make_bool(inout self: Self, msg: Bool) -> String:
        if msg:
            return self.make_msg(REDIS_BOOL, "t")
        else:
            return self.make_msg(REDIS_BOOL, "f")

    fn make_double(inout self: Self, msg: None) -> String:
        return self.make_msg(REDIS_DOUBLE, "nan")

    fn make_double(inout self: Self, msg: Float32) -> String:
        if isnan(msg):
            return self.make_msg(REDIS_DOUBLE, "nan")
        elif isinf(msg):
            if msg > 0:
                return self.make_msg(REDIS_DOUBLE, "inf")
            else:
                return self.make_msg(REDIS_DOUBLE, "-inf")
        else:
            return self.make_msg(REDIS_DOUBLE, String(msg))

    fn make_big_integer(inout self: Self, msg: Int64) -> String:
        return self.make_msg(REDIS_BIG_NUMBER, String(msg))


fn reply_to_message(msg: String) -> String:
    var parser = FiredisParser(msg)

    return parser.make_string("PONG")


fn respond_to_client(new_sockfd: c_int, workers: Int) -> None:
    with Runtime() as rt:

        @always_inline
        @parameter
        fn handle_messages(n: Int):
            while True:
                let buf_size = 1024
                let buf = Pointer[c_char]().alloc(buf_size)
                let bytes_recv = recv(new_sockfd, buf, buf_size, 0)

                print("> bytes received:", bytes_recv)

                if bytes_recv <= 0:
                    print("> failed to receive message, client disconnected?")
                    break

                let msg = c_charptr_to_string(buf, bytes_recv)
                print("> recived message:", msg)

                let reply = reply_to_message(msg)
                if send(new_sockfd, to_char_ptr(reply), len(reply), 0) == -1:
                    print("> failed to send reply:", reply)
                    break

                print("> message sent succesfully:", reply)

        parallelize[handle_messages](rt, workers)


fn wait_for_clients(sockfd: c_int, workers: Int) -> None:
    print("> waiting for connections...")

    while True:
        with Runtime() as rt:

            @always_inline
            @parameter
            fn handle_client(n: Int):
                let addr_ptr = Pointer[sockaddr].alloc(1)
                var sin_size = socklen_t(sizeof[socklen_t]())

                let new_sockfd = accept(
                    sockfd, addr_ptr, Pointer[socklen_t].address_of(sin_size)
                )

                if new_sockfd == -1:
                    print("> accept failed")
                    return
                else:
                    print("> new connection accepted with fd:", new_sockfd)

                respond_to_client(new_sockfd, workers)

            parallelize[handle_client](rt, workers)


fn main() -> None:
    let config = load_config()

    print("> starting firedis at ip addr:", config.host, "port:", config.port, "ðŸ”¥")

    let address_family = AF_INET
    var ip_buf_size = 4
    if address_family == AF_INET6:
        ip_buf_size = 16

    let ip_buf = Pointer[c_void].alloc(ip_buf_size)
    let conv_status = inet_pton(address_family, to_char_ptr(config.host), ip_buf)
    let raw_ip = ip_buf.bitcast[c_uint]().load()

    print("> inet_pton:", raw_ip, "status:", conv_status)

    let bin_port = htons(config.port)

    print("> htons:", bin_port)

    var ai = sockaddr_in(address_family, bin_port, raw_ip, StaticTuple[8, c_char]())
    let ai_ptr = Pointer[sockaddr_in].address_of(ai).bitcast[sockaddr]()

    let sockfd = socket(address_family, SOCK_STREAM, 0)
    if sockfd == -1:
        print("> socket creation error")

    print("> sockfd:", sockfd)

    var yes: Int = 1
    if (
        setsockopt(
            sockfd,
            SOL_SOCKET,
            SO_REUSEADDR,
            Pointer[Int].address_of(yes).bitcast[c_void](),
            sizeof[Int](),
        )
        == -1
    ):
        print("> set socket options failed")

    if bind(sockfd, ai_ptr, sizeof[sockaddr_in]()) == -1:
        _ = shutdown(sockfd, SHUT_RDWR)
        print("> binding socket failed")

    if listen(sockfd, c_int(128)) == -1:
        print("> listen", sockfd, "failed")

    print("> started at:", config.host, "port:", config.port, "with fd:", sockfd)

    print(
        "> using",
        config.workers,
        "workers",
        "out of",
        config.max_clients,
        "max clients",
    )
    wait_for_clients(sockfd, config.workers)

    _ = shutdown(sockfd, SHUT_RDWR)
