from python.python import Python
from python.object import PythonObject
from algorithm.functional import parallelize, num_cores
from runtime.llcl import Runtime


fn parse(msg: PythonObject) -> String:
    try:
        let msg = msg.decode().split("\r\n")

        Python.add_to_path(".")
        let len_py = Python.import_module("builtins").len

        if len_py(msg) <= 1:
            return ""

        return msg[-2].upper().to_string()
    except e:
        print("> [parse] err:", e.value)

        return ""


fn pong(socket: PythonObject) -> Bool:
    let pong = "+PONG\r\n"

    try:
        _ = socket.send(PythonObject(pong).encode("utf-8"))
    except e:
        print("> [pong] err:", e.value)

        return False

    return True


fn handle_msg(socket: PythonObject, raw_msg: PythonObject) -> Bool:
    let msg = parse(raw_msg)

    if msg == "COMMAND":
        return pong(socket)
    if msg == "PING":
        return pong(socket)

    return False


fn handle_client(socket: PythonObject) -> None:
    while True:
        try:
            let data = socket.recv(1024)

            if handle_msg(socket, data):
                continue
            else:
                break
        except e:
            print("> [handle_client] err:", e.value, "exiting...")


fn main():
    let firedis_py: PythonObject
    let host: StringRef = "localhost"
    let port: Int = 6379
    let reuse_port: Bool = True

    let socket: PythonObject
    let server_socket: PythonObject

    print("> [main] starting firedis on host:", host, "and port", port, "ðŸ”¥")

    try:
        Python.add_to_path(".")

        firedis_py = Python.import_module("firedis")
        server_socket = firedis_py.create_server(host, port, reuse_port)
    except e:
        print("> [main] err:", e.value)

    with Runtime() as rt:
        while True:
            print("> [main] waiting for client...")
            let socket: PythonObject
            let addr: PythonObject
            let accept: PythonObject

            try:
                accept = server_socket.accept()

                socket = accept[0]
                addr = accept[1]

                print("> [main] client connected:", addr)
            except e:
                print("> [main] e", e.value)

            @parameter
            fn worker(n: Int) -> None:
                print("> [main] worker", n, "started")

                handle_client(socket)

                print("> [main] worker", n, "exiting")

            parallelize[worker](rt, 4)
